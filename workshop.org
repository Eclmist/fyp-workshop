#+TITLE: Presentation about random stuff
#+AUTHOR: Jing Yen Loh
#+EMAIL: lohjingyen@gmail.com

* Introduction
  
* JavaScript
** Scopes + let & const
   In ES6, 2 new keywords were introduced, ~let~ and ~const~.
   
   Similar to ~var~, they're used for variable declarations.
   #+BEGIN_SRC js
     let x = 666000;
     const y = 420;

     return x + y;
   #+END_SRC

   ~const~ is similar to the ~const~ you've seen in C#, where the value of the
   constant cannot be changed through re-assignment, and it cannot be
   redeclared. Here's a little snippet directly copy pasted from MDN to
   illustrate what I mean.
   #+BEGIN_SRC js
     const number = 42;

     try {
         number = 99;
     } catch(err) {
         console.log(err);
         // expected output: TypeError: invalid assignment to const `number'
         // Note - error messages will vary depending on browser
     }

     console.log(number);
     // expected output: 42
   #+END_SRC
   
   One common misconception, however, is that ~const~ makes the value it holds
   immutable (meaning it cannot be modified). This is *not true*.
   #+BEGIN_SRC js
     const arr = [1, 2, 3, 4, 5];

     arr.push(6);

     return arr; // returns [1, 2, 3, 4, 5, 6]
   #+END_SRC
   With ~const~, you're still able to mutate the value it's holding. You simply
   can't change the /reference/.
   #+BEGIN_SRC js
     const arr = [1, 2, 3, 4, 5];

     let copy = [...arr, 6];

     arr = copy; // TypeError: Assignment to constant variable
   #+END_SRC

   ~let~ works similarly to ~var~, allowing you to modify references.
   #+BEGIN_SRC js
     let x = 1;
     console.log(x);

     x = 'chicken';
     console.log(x);

     x = ['1', '2', '3', '4', '5'].map(parseInt);
     return x;
   #+END_SRC
   
   Wait... if so.... what's the purpose of ~let~? Why not just keep using ~var~,
   and keep ~const~ alongside that?
   
   We have to go a little deeper.
*** Scopes
    In computer science, a closure is a...
    #+BEGIN_VERSE
    technique for implementing lexically scoped name binding
    in a language with first-class functions -- Wikipedia
    #+END_VERSE
    
    *What* is that nonsense?!?!?! Ok, ok, let's ignore the wikipedia definitions
    today. Here's something that's a little different from C# or Java:
    /variables in JavaScript are actually "function scoped"./
    
    #+BEGIN_SRC js
      function aThousand () {
          for (var i = 0; i < 1000; i++) {
              // Do nothing, I'm just gonna use
              // a for loop to illustrate
          }
          return i;
      }

      return aThousand();
    #+END_SRC
    
    The reason that was possible is because the /scope/ of ~i~ wasn't just
    limited to the for loop, it's actually a declaration that can be accessed
    within the function itself.
    
    It turns out that a fuction is a *closure* in JS. Think of it as the
    function being the thing that creates a /scope/.
    
    This is a little different from languages you're probably used to, like C#.
    #+BEGIN_SRC csharp
    int AThousand()
    {
        for (var i = 0; i < 1000; i++)
        {
            // Do nothing
        }
        return i; // The name 'i' does not exist in the current context
    }
    #+END_SRC
    
    I'm waving my hand with a lot of magic here, but essentially think of
    variables in these language as ~{}~ scoped, that is to say, a pair of curly
    braces forms a scope.
    
    Thus, one reason ~let~ and ~const~ were introduced was to make things more
    predictable to people who are already accustomed to such languages.
*** Personal preference
    I use ~const~ almost exclusively, unless I know I explicitly want a mutable
    reference, in which case I use ~let~. I find this helps me reason about my
    code better. YMMV.
    
** Equality
*** Problem
    
    What do you think is gonna happen below?
    #+BEGIN_SRC js
    return 1 == 1;
    #+END_SRC

    #+RESULTS:
    : true

    What about this?
    #+BEGIN_SRC js
    return 1 === 1;
    #+END_SRC

    #+RESULTS:
    : true
   
    ðŸ˜² So what's the difference ??!?!?
   
    Well, let's try this...
    #+BEGIN_SRC js
    return 1 == '1';
    #+END_SRC

    #+RESULTS:
    : true

    *Huh?*
   
    #+BEGIN_SRC js
    return 1 == [1];
    #+END_SRC

    #+RESULTS:
    : true
   
    *!!!*
    #+NAME: number-compare-boolean
    #+BEGIN_SRC js
    return 1 == true; // wat
    #+END_SRC

    #+RESULTS:
    : true
   
    Ok, ok, we get the point. Why does this happen?
   
    In JavaScript, ~==~ is the /abstract equality operator/. When comparing
    values with ~==~, it converts both values to a common type. As an example,
    with [[number-compare-boolean]], it converts the ~true~ to a number before
    comparing.
   
    #+BEGIN_SRC js
      return Number(true)
    #+END_SRC

    #+RESULTS:
    : 1
   
    So since 1 is equal to 1, ~1 == true~ evaluates to true.

*** Solution
    ~===~ is the strict equality operator. If the values are of different types,
    they're unequal.
    
    #+BEGIN_SRC js
      console.log(1 === '1');
      console.log(1 === [1]);
      console.log(1 === true);
      return (undefined === null);
    #+END_SRC

    #+RESULTS:
    : false
    : false
    : false
    : false
    
    Well, most of the time anyway. You still get magical edge
    cases like this.
    
    #+BEGIN_SRC js
      return NaN === NaN;
    #+END_SRC

    #+RESULTS:
    : false
    
    TLDR; with JavaScript, *ALWAYS* use the strict equality operator (~===~) for
    comparison unless you really know what you're doing with ~==~.

** Arrow Functions
   Consider the following function:
   #+BEGIN_SRC js
     function multiply (x, y) {
         return x * y;
     }
   #+END_SRC
   
   - [ ] Something about anonymous
   
   Arrow functions were influenced by CoffeeScript, a functional programming
   language that transpiled into JavaScript.
   
   They make simple functions a lot more concise.
   
   #+BEGIN_SRC js
     const multiply = (x, y) => x * y;
   #+END_SRC

   The difference is particularly apparent when they're passed as arguments e.g.
   in Promise chains.
   #+BEGIN_SRC js
     fetch('www.example.com/api/v3')
         .then(function (response) {
             return response.json();
         })
         .then(function (json) {
             console.log(json);
         })

     /* Versus */
     fetch('www.example.com/api/v3')
         .then(response => response.json())
         .then(json => console.log(json))
   #+END_SRC
   
   But surely they weren't added just for a little syntactic sugar?

** "Classes"
** Promises
** Generic tooling
*** ESLint
    Fundamentally, ESLint is a utility that enforces a collection of rules (a
    style guide) that your JS code needs to adhere to. By enforcing these set of
    rules, ESLint is able to catch errors that you might have failed to notice
    when writing JS (e.g. a dangling comma, syntax errors, accidental globals).
    
    ESLint further enforces code formatting conventions, prompting you to write
    code in a uniform fashion that can be easily understood and maintained by
    your team.
    
    Moreover, ESLint is plugin based, and hence, different kinds of style guides
    can be configured for your project to catch JS errors and enforce formatting
    conventions.
    
    Here's a quick look of ESLint in action in Visual Studio Code:
    
    [[file:images/eslint-in-action.png]]
    
    To sum up, ESLint is a utility implemeted in JS projects to ensure that the
    code you write meets the rules it enforces, so as to keep your code base
    consistent and as error free as possbile.
    
*** Webpack
* Web

* Git
  
