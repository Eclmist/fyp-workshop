#+TITLE: Presentation about random stuff
#+AUTHOR: Jing Yen Loh
#+EMAIL: lohjingyen@gmail.com

* Introduction
  
* JavaScript
** Scopes + let & const
   In ES6, 2 new keywords were introduced, ~let~ and ~const~.
   
   Similar to ~var~, they're used for variable declarations.
   #+BEGIN_SRC js
     let x = 666000;
     const y = 420;

     return x + y;
   #+END_SRC

   ~const~ is similar to the ~const~ you've seen in C#, where the value of the
   constant cannot be changed through re-assignment, and it cannot be
   redeclared. Here's a little snippet directly copy pasted from MDN to
   illustrate what I mean.
   #+BEGIN_SRC js
     const number = 42;

     try {
         number = 99;
     } catch(err) {
         console.log(err);
         // expected output: TypeError: invalid assignment to const `number'
         // Note - error messages will vary depending on browser
     }

     console.log(number);
     // expected output: 42
   #+END_SRC
   
   One common misconception, however, is that ~const~ makes the value it holds
   immutable (meaning it cannot be modified). This is *not true*.
   #+BEGIN_SRC js
     const arr = [1, 2, 3, 4, 5];

     arr.push(6);

     return arr; // returns [1, 2, 3, 4, 5, 6]
   #+END_SRC
   With ~const~, you're still able to mutate the value it's holding. You simply
   can't change the /reference/.
   #+BEGIN_SRC js
     const arr = [1, 2, 3, 4, 5];

     let copy = [...arr, 6];

     arr = copy; // TypeError: Assignment to constant variable
   #+END_SRC

   ~let~ works similarly to ~var~, allowing you to modify references.
   #+BEGIN_SRC js
     let x = 1;
     console.log(x);

     x = 'chicken';
     console.log(x);

     x = ['1', '2', '3', '4', '5'].map(parseInt);
     return x;
   #+END_SRC
   
   Wait... if so.... what's the purpose of ~let~? Why not just keep using ~var~,
   and keep ~const~ alongside that?
   
   We have to go a little deeper.
*** Scopes
    In computer science, a closure is a...
    #+BEGIN_VERSE
    technique for implementing lexically scoped name binding
    in a language with first-class functions -- Wikipedia
    #+END_VERSE
    
    *What* is that nonsense?!?!?! Ok, ok, let's ignore the wikipedia definitions
    today. Here's something that's a little different from C# or Java:
    /variables in JavaScript are actually "function scoped"./
    
    #+BEGIN_SRC js
      function aThousand () {
          for (var i = 0; i < 1000; i++) {
              // Do nothing, I'm just gonna use
              // a for loop to illustrate
          }
          return i;
      }

      return aThousand();
    #+END_SRC
    
    The reason that was possible is because the /scope/ of ~i~ wasn't just
    limited to the for loop, it's actually a declaration that can be accessed
    within the function itself.
    
    It turns out that a fuction is a *closure* in JS. Think of it as the
    function being the thing that creates a /scope/.
    
    This is a little different from languages you're probably used to, like C#.
    #+BEGIN_SRC csharp
    int AThousand()
    {
        for (var i = 0; i < 1000; i++)
        {
            // Do nothing
        }
        return i; // The name 'i' does not exist in the current context
    }
    #+END_SRC
    
    I'm waving my hand with a lot of magic here, but essentially think of
    variables in these language as ~{}~ scoped, that is to say, a pair of curly
    braces forms a scope.
    
    Thus, one reason ~let~ and ~const~ were introduced was to make things more
    predictable to people who are already accustomed to such languages.
*** Personal preference
    I use ~const~ almost exclusively, unless I know I explicitly want a mutable
    reference, in which case I use ~let~. I find this helps me reason about my
    code better. YMMV.
    
** Equality
*** Problem
    
    What do you think is gonna happen below?
    #+BEGIN_SRC js
    return 1 == 1;
    #+END_SRC

    #+RESULTS:
    : true

    What about this?
    #+BEGIN_SRC js
    return 1 === 1;
    #+END_SRC

    #+RESULTS:
    : true
   
    ðŸ˜² So what's the difference ??!?!?
   
    Well, let's try this...
    #+BEGIN_SRC js
    return 1 == '1';
    #+END_SRC

    #+RESULTS:
    : true

    *Huh?*
   
    #+BEGIN_SRC js
    return 1 == [1];
    #+END_SRC

    #+RESULTS:
    : true
   
    *!!!*
    #+NAME: number-compare-boolean
    #+BEGIN_SRC js
    return 1 == true; // wat
    #+END_SRC

    #+RESULTS:
    : true
   
    Ok, ok, we get the point. Why does this happen?
   
    In JavaScript, ~==~ is the /abstract equality operator/. When comparing
    values with ~==~, it converts both values to a common type. As an example,
    with [[number-compare-boolean]], it converts the ~true~ to a number before
    comparing.
   
    #+BEGIN_SRC js
      return Number(true)
    #+END_SRC

    #+RESULTS:
    : 1
   
    So since 1 is equal to 1, ~1 == true~ evaluates to true.

*** Solution
    ~===~ is the strict equality operator. If the values are of different types,
    they're unequal.
    
    #+BEGIN_SRC js
      console.log(1 === '1');
      console.log(1 === [1]);
      console.log(1 === true);
      return (undefined === null);
    #+END_SRC

    #+RESULTS:
    : false
    : false
    : false
    : false
    
    Well, most of the time anyway. You still get magical edge
    cases like this.
    
    #+BEGIN_SRC js
      return NaN === NaN;
    #+END_SRC

    #+RESULTS:
    : false
    
    TLDR; with JavaScript, *ALWAYS* use the strict equality operator (~===~) for
    comparison unless you really know what you're doing with ~==~.

*** Examples
    Therefore, avoid writing things like
    #+BEGIN_SRC js

      try {
          var supposedToBeInt = await someApiYouCantGuaranteeDatatypeOf(); // supposedToBeInt was actually '420'
          if (supposedToBeInt == 420) { // Please use strict equality here !!
              // Do the right stuff
          } else {
              throw new Error(`Hey, it wasn't 420 !!`);
          }
      } catch (e) {
          console.error(e);
      }
    #+END_SRC
    
** Arrow Functions
   Consider the following function:
   #+BEGIN_SRC js
     function multiply (x, y) {
         return x * y;
     }
   #+END_SRC
   
   - [ ] Something about anonymous
   
   Arrow functions were influenced by CoffeeScript, a functional programming
   language that transpiled into JavaScript.
   
   They make simple functions a lot more concise.
   
   #+BEGIN_SRC js
     const multiply = (x, y) => x * y;
   #+END_SRC

   The difference is particularly apparent when they're passed as arguments e.g.
   in Promise chains.
   #+BEGIN_SRC js
     fetch('www.example.com/api/v3')
         .then(function (response) {
             return response.json();
         })
         .then(function (json) {
             console.log(json);
         })

     /* Versus */
     fetch('www.example.com/api/v3')
         .then(response => response.json())
         .then(json => console.log(json))
   #+END_SRC
   
   But surely they weren't added just for a little syntactic sugar?

** "Classes"
** Promises
** Generic tooling
*** ESLint
    Fundamentally, ESLint is a utility that enforces a collection of rules (a
    style guide) that your JS code needs to adhere to. By enforcing these set of
    rules, ESLint is able to catch errors that you might have failed to notice
    when writing JS (e.g. a dangling comma, syntax errors, accidental globals).
    
    ESLint further enforces code formatting conventions, prompting you to write
    code in a uniform fashion that can be easily understood and maintained by
    your team.
    
    Moreover, ESLint is plugin based, and hence, different kinds of style guides
    can be configured for your project to catch JS errors and enforce formatting
    conventions.
    
    Here's a quick look of ESLint in action in Visual Studio Code:
    
    [[file:images/eslint-in-action.png]]
    
    To sum up, ESLint is a utility implemeted in JS projects to ensure that the
    code you write meets the rules it enforces, so as to keep your code base
    consistent and as error free as possbile.
    
*** TODO Webpack
    In the context of JS projects, Webpack is a module bundler that travels a
    project, forming a graph of its dependencies, then bundling all these
    dependencies into a bundle to be served to users.
    
    Back in the olden days, we used to include javascript files using the
    ~<script>~ tag.
    #+BEGIN_SRC html
      <script src="some-file-somewhere.js'></script>
    #+END_SRC
    
    If we have a bunch of scripts, they'd end up something like this. The below
    example is stolen from our beloved WebA project, including the ~link~ tags
    as well.
    #+BEGIN_SRC html
      <link href="~/lib/bootstrap/dist/css/bootstrap.css" rel="stylesheet" />
      <link href="~/lib/bootstrap-table/dist/bootstrap-table.css" rel="stylesheet" /> 
      <link href="~/css/site.css" rel="stylesheet" />
      <link rel="stylesheet" href="~/css/sticky_footer.css" />
      <link href="~/lib/noty/lib/noty.css" rel="stylesheet" />
      <link href="~/lib/bootstrap-switch/dist/css/bootstrap3/bootstrap-switch.css" rel="stylesheet"/>
      <link href="~/lib/DataTables-1.10.16/css/jquery.dataTables.css" rel="stylesheet"/>
      <link href="~/lib/bootstrap-datepicker/dist/css/bootstrap-datepicker.css" rel="stylesheet" />
      <link href="~/lib/bootstrap-timepicker/css/timepicker.css" rel="stylesheet"/>


      <script src="~/lib/jquery/dist/jquery.js"></script>
      <script src="~/lib/jquery-validation/dist/jquery.validate.js"></script>
      <script src="~/lib/jquery-validation/dist/additional-methods.js"></script>
      <script src="~/lib/js-cookie/src/js.cookie.js"></script>
      <script src="~/lib/bootstrap/dist/js/bootstrap.js"></script>
      <script src="~/lib/bootstrap-table/dist/bootstrap-table.js"></script>
      <script src="~/lib/noty/lib/noty.js"></script>
      <script src="~/lib/moment/min/moment.min.js"></script>
      <script src="~/lib/he/he.js"></script>
      <script src="~/lib/bootstrap-table-contextmenu/dist/bootstrap-table-contextmenu.min.js"></script>
      <script src="~/lib/bootstrap-switch/dist/js/bootstrap-switch.js"></script>
      <script src="~/lib/DataTables-1.10.16/js/jquery.dataTables.js"></script>
      <script src="~/lib/bootstrap-datepicker/dist/js/bootstrap-datepicker.js"></script>
      <script src="~/lib/bootstrap-timepicker/js/bootstrap-timepicker.js"></script>
    #+END_SRC
    
    WebA was a simple project if you compare it to the scale of web applications
    that are around. Have you ever inspected the source of some older ecommerce
    site and seen 30 script tags alone?
    
    Each script ends up adding something else to the global scope. I'm not going
    in depth into why this is bad, but just know that this potentially causes
    some problems and conflicts.
    
    This is one of the problem that webpack solves. Now, instead of including
    script files one by one, webpack builds a /dependency graph/ from all the
    modules you /require/, starting from an entry point.
    #+BEGIN_SRC js
      // app.js
      const express = require('express');

      const app = express();
    #+END_SRC
    In the above example, let's assume app.js was the entry point for Webpack.
    With the ~require~, Webpack now knows this app /requires/ express. It'll go
    into express and look into the library.
    
    Here's the source for ~index.js~ for Express.
    #+BEGIN_SRC js
      /*!
       ,* express
       ,* Copyright(c) 2009-2013 TJ Holowaychuk
       ,* Copyright(c) 2013 Roman Shtylman
       ,* Copyright(c) 2014-2015 Douglas Christopher Wilson
       ,* MIT Licensed
       ,*/

      'use strict';

      module.exports = require('./lib/express');
    #+END_SRC

    From here, it'll continue on into ~./lib/express~ and on and on, until it
    finally has everything it needs. It'll then bundle all this stuff up.
    
    In Node.js projects nowadays, Webpack is often pre-configured in many
    templates. For example, the cli tool ~create-react-app~ allows you to
    generate a React project with a all the webpack configuration done.
    Generally, it's unlikely you'll need to configure Webpack manually (thank
    god) but it's always helpful to know how things are bundled together.
* Web

* Git
  
