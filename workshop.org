#+TITLE: Presentation about random stuff
#+AUTHOR: Jing Yen Loh
#+EMAIL: lohjingyen@gmail.com

* Introduction
  
* JavaScript
** Closures + let & const
   In ES6, 2 new keywords were introduced, ~let~ and ~const~.
   
   Similar to ~var~, they're used for variable declarations.
   #+BEGIN_SRC js
     let x = 666000;
     const y = 420;

     return x + y;
   #+END_SRC

   ~const~ is similar to the ~const~ you've seen in C#, where the value of the
   constant cannot be changed through re-assignment, and it cannot be
   redeclared. Here's a little snippet directly copy pasted from MDN to
   illustrate what I mean.
   #+BEGIN_SRC js
     const number = 42;

     try {
         number = 99;
     } catch(err) {
         console.log(err);
         // expected output: TypeError: invalid assignment to const `number'
         // Note - error messages will vary depending on browser
     }

     console.log(number);
     // expected output: 42
   #+END_SRC
   
   One common misconception, however, is that ~const~ makes the value it holds
   immutable (meaning it cannot be modified). This is *not true*.
   #+BEGIN_SRC js
     const arr = [1, 2, 3, 4, 5];

     arr.push(6);

     return arr; // returns [1, 2, 3, 4, 5, 6]
   #+END_SRC
   With ~const~, you're still able to mutate the value it's holding. You simply
   can't change the /reference/.
   #+BEGIN_SRC js
     const arr = [1, 2, 3, 4, 5];

     let copy = [...arr, 6];

     arr = copy; // TypeError: Assignment to constant variable
   #+END_SRC

   ~let~ works similarly to ~var~, allowing you to modify references.
   #+BEGIN_SRC js
     let x = 1;
     console.log(x);

     x = 'chicken';
     console.log(x);

     x = ['1', '2', '3', '4', '5'].map(parseInt);
     return x;
   #+END_SRC
   
   Wait... if so.... what's the purpose of ~let~? Why not just keep using ~var~,
   and keep ~const~ alongside that?
   
   We have to go a little deeper.
** Equality
*** Problem
    
    What do you think is gonna happen below?
    #+BEGIN_SRC js
    return 1 == 1;
    #+END_SRC

    #+RESULTS:
    : true

    What about this?
    #+BEGIN_SRC js
    return 1 === 1;
    #+END_SRC

    #+RESULTS:
    : true
   
    ðŸ˜² So what's the difference ??!?!?
   
    Well, let's try this...
    #+BEGIN_SRC js
    return 1 == '1';
    #+END_SRC

    #+RESULTS:
    : true

    *Huh?*
   
    #+BEGIN_SRC js
    return 1 == [1];
    #+END_SRC

    #+RESULTS:
    : true
   
    *!!!*
    #+NAME: number-compare-boolean
    #+BEGIN_SRC js
    return 1 == true; // wat
    #+END_SRC

    #+RESULTS:
    : true
   
    Ok, ok, we get the point. Why does this happen?
   
    In JavaScript, ~==~ is the /abstract equality operator/. When comparing
    values with ~==~, it converts both values to a common type. As an example,
    with [[number-compare-boolean]], it converts the ~true~ to a number before
    comparing.
   
    #+BEGIN_SRC js
      return Number(true)
    #+END_SRC

    #+RESULTS:
    : 1
   
    So since 1 is equal to 1, ~1 == true~ evaluates to true.

*** Solution
    ~===~ is the strict equality operator. If the values are of different types,
    they're unequal.
    
    #+BEGIN_SRC js
      console.log(1 === '1');
      console.log(1 === [1]);
      console.log(1 === true);
      return (undefined === null);
    #+END_SRC

    #+RESULTS:
    : false
    : false
    : false
    : false
    
    Well, most of the time anyway. You still get magical edge
    cases like this.
    
    #+BEGIN_SRC js
      return NaN === NaN;
    #+END_SRC

    #+RESULTS:
    : false
    
    TLDR; with JavaScript, *ALWAYS* use the strict equality operator (~===~) for
    comparison unless you really know what you're doing with ~==~.

** Arrow Functions
   Consider the following function:
   #+BEGIN_SRC js
     function multiply (x, y) {
         return x * y;
     }
   #+END_SRC
   
   - [ ] Something about anonymous
   
   Arrow functions were influenced by CoffeeScript, a functional programming
   language that transpiled into JavaScript.
   
   They make simple functions a lot more concise.
   
   #+BEGIN_SRC js
     const multiply = (x, y) => x * y;
   #+END_SRC

   The difference is particularly apparent when they're passed as arguments e.g.
   in Promise chains.
   #+BEGIN_SRC js
     fetch('www.example.com/api/v3')
         .then(function (response) {
             return response.json();
         })
         .then(function (json) {
             console.log(json);
         })

     /* Versus */
     fetch('www.example.com/api/v3')
         .then(response => response.json())
         .then(json => console.log(json))
   #+END_SRC
   
   But surely they weren't added just for a little syntactic sugar?

** "Classes"
** Promises
** Generic tooling
*** ESLint
*** Webpack
* Web

* Git
