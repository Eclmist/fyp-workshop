#+TITLE: Presentation about random stuff
#+AUTHOR: Jing Yen Loh
#+EMAIL: lohjingyen@gmail.com

* Introduction
  
* JavaScript
** Equality
*** Problem
    
    What do you think is gonna happen below?
    #+BEGIN_SRC js
    return 1 == 1;
    #+END_SRC

    #+RESULTS:
    : true

    What about this?
    #+BEGIN_SRC js
    return 1 === 1;
    #+END_SRC

    #+RESULTS:
    : true
   
    ðŸ˜² So what's the difference ??!?!?
   
    Well, let's try this...
    #+BEGIN_SRC js
    return 1 == '1';
    #+END_SRC

    #+RESULTS:
    : true

    *Huh?*
   
    #+BEGIN_SRC js
    return 1 == [1];
    #+END_SRC

    #+RESULTS:
    : true
   
    *!!!*
    #+NAME: number-compare-boolean
    #+BEGIN_SRC js
    return 1 == true; // wat
    #+END_SRC

    #+RESULTS:
    : true
   
    Ok, ok, we get the point. Why does this happen?
   
    In JavaScript, ~==~ is the /abstract equality operator/. When comparing
    values with ~==~, it converts both values to a common type. As an example,
    with [[number-compare-boolean]], it converts the ~true~ to a number before
    comparing.
   
    #+BEGIN_SRC js
      return Number(true)
    #+END_SRC

    #+RESULTS:
    : 1
   
    So since 1 is equal to 1, ~1 == true~ evaluates to true.

*** Solution
    ~===~ is the strict equality operator. If the values are of different types,
    they're unequal.
    
    #+BEGIN_SRC js
      console.log(1 === '1');
      console.log(1 === [1]);
      console.log(1 === true);
      return (undefined === null);
    #+END_SRC

    #+RESULTS:
    : false
    : false
    : false
    : false
    
    Well, most of the time anyway. You still get magical edge
    cases like this.
    
    #+BEGIN_SRC js
      return NaN === NaN;
    #+END_SRC

    #+RESULTS:
    : false
    
    TLDR; with JavaScript, *ALWAYS* use the strict equality operator (~===~) for
    comparison unless you really know what you're doing with ~==~.

** Arrow Functions
   Consider the following function:
   #+BEGIN_SRC js
     function multiply (x, y) {
         return x * y;
     }
   #+END_SRC
   
   - [ ] Something about anonymous
   
   Arrow functions were influenced by CoffeeScript, a functional programming
   language that transpiled into JavaScript.
   
   They make simple functions a lot more concise.
   
   #+BEGIN_SRC js
     const multiply = (x, y) => x * y;
   #+END_SRC

   The difference is particularly apparent when they're passed as arguments e.g.
   in Promise chains.
   #+BEGIN_SRC js
     fetch('www.example.com/api/v3')
         .then(function (response) {
             return response.json();
         })
         .then(function (json) {
             console.log(json);
         })

     /* Versus */
     fetch('www.example.com/api/v3')
         .then(response => response.json())
         .then(json => console.log(json))
   #+END_SRC
   
   But surely they weren't added just for a little syntactic sugar?

** "Classes"
** Promises
** Generic tooling
* Web

* Git
